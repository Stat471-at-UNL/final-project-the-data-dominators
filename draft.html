<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Initial Draft</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="draft_files/libs/clipboard/clipboard.min.js"></script>
<script src="draft_files/libs/quarto-html/quarto.js"></script>
<script src="draft_files/libs/quarto-html/popper.min.js"></script>
<script src="draft_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="draft_files/libs/quarto-html/anchor.min.js"></script>
<link href="draft_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="draft_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="draft_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="draft_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="draft_files/libs/bootstrap/bootstrap-973236bd072d72a04ee9cd82dcc9cb29.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Initial Draft</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="cleaning-and-packaging-the-missouri-brfss-data" class="level1">
<h1>Cleaning and Packaging the Missouri BRFSS Data</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>We developed an R package that includes cleaned 2023 and 2024 BRFSS datasets for the state of Missouri, focusing specifically on the Cognitive Decline and Tobacco Use modules. We chose this project because accessing BRFSS data currently requires downloading and manually extracting large ZIP files from the official website, which is time-consuming and inconvenient. Our package is designed to make these data easily accessible and ready to use directly within RStudio. Our goal is to simplify the workflow for other users and help BRFSS become a well-known, user-friendly resource that can be loaded as easily as built-in datasets like <code>iris</code>. In this project, we will identify missing values in the Cognitive Decline and Tobacco Use modules, characterize the types of missingness, and impute those missing values. Finally, we will transform and tidy the data so that it is well structured and easy to use in a public R package.</p>
</section>
<section id="dataset" class="level2">
<h2 class="anchored" data-anchor-id="dataset">Dataset</h2>
<p>The BRFSS data for our project is found at this <a href="https://www.cdc.gov/brfss/annual_data/annual_data.htm">link</a>. The CDC along with state health departments regularly conduct telephone surveys to collect this health-related data about U.S. residents. We downloaded the 2023 and 2024 data (most recent releases) in the SAS Transport Format, both provided in separate .zip files. Reading in these files can be easily accomplished with the help of the <code>haven</code> R package.</p>
<p>To load the data:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(haven)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>brfss_2024 <span class="ot">&lt;-</span> <span class="fu">read_xpt</span>(<span class="fu">unz</span>(<span class="st">"data/LLCP2024XPT.zip"</span>, <span class="st">"LLCP2024.XPT "</span>)) <span class="co"># 457,670 records</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>brfss_2023 <span class="ot">&lt;-</span> <span class="fu">read_xpt</span>(<span class="fu">unz</span>(<span class="st">"data/LLCP2023XPT.zip"</span>, <span class="st">"LLCP2023.XPT "</span>)) <span class="co"># 433,323 records</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We filtered the dataset to only use records from the state of Missouri. Our original idea was to use Nebraska’s data, but since it has limited topics, we chose our southeastern neighbors. The Missouri data included information on a wide range of topics, but we chose to focus on the <strong>Cognitive Decline</strong> and <strong>Tobacco Use</strong> modules. We got rid of the rest of the columns (that weren’t used in the missing value imputation either), and analyzed/cleaned those two.</p>
</section>
<section id="cleaning-the-data" class="level2">
<h2 class="anchored" data-anchor-id="cleaning-the-data">Cleaning the Data</h2>
<p>The main effort of our project went into cleaning the dataset, which grew to be quite the task. For starters, the dataset is <em>huge</em>, which is quite overwhelming to someone unfamiliar with the data. There is documentation in place, but it only makes analysis slightly easier. Combining two years’ worth of data just makes the problem worse, as some of the column names didn’t match up.</p>
<p>The BRFSS data also naturally has lots of missing data. This is because, in each state, surveyors pick and choose only a handful of modules out of the wide variety of topics. This means that a state has missing values in the columns relating to all the other modules. Additionally, there are frequent missing values even in the columns relating to modules that a state was questioned on.</p>
<p>These factors combined made cleaning the dataset a tough task but, more importantly, a necessary one. This turned into a 3-step process: investigating the missing values, imputing the missing values, and tidying the dataset.</p>
<section id="investigating-missing-values" class="level3">
<h3 class="anchored" data-anchor-id="investigating-missing-values">Investigating Missing Values</h3>
<p>Before deciding how to handle missing data, we examined how often values were missing and what type of missingness might be present (MCAR, MAR, or MNAR).</p>
<p>First, we summarized the extent of missing data for the tobacco and cognitive variables in the 2023 and 2024 Missouri samples. We found that several items had a large amount of missingness, especially in the cognitive module (<code>CDHOUS1</code>, <code>CDSOCIA1</code>), where more than 40–90% of responses were missing or not applicable.</p>
<p><img src="images/missing.png" class="img-fluid">We then formally tested whether the missing data could be considered Missing Completely At Random (MCAR) using Little’s MCAR test (<code>naniar::mcar_test</code>). We applied this test separately to the tobacco variables and the cognitive variables for both years. In all cases, the MCAR test was highly significant (p &lt; 0.001), indicating strong evidence against MCAR. This suggests that missingness is related to observed or unobserved characteristics, and it supports the use of multiple imputations</p>
</section>
<section id="imputing-missing-values" class="level3">
<h3 class="anchored" data-anchor-id="imputing-missing-values">Imputing Missing Values</h3>
<p>After analyzing the missing values, we imputed three fields from our chosen modules:</p>
<ul>
<li><code>SMOKE100</code>: Have you smoked at Least 100 Cigarettes
<ul>
<li>1 - Yes; 2 - No; 7 - Don’t Know; 9 - Refused</li>
</ul></li>
<li><code>ECIGNOW</code>: Do you now use e-cigarettes, or vaping products?
<ul>
<li>1 - Never; 2 - Every day; 3 - Some days; 4 - Not right now; 7 - Don’t know; 9 - Refused</li>
</ul></li>
<li><code>CIMEMLO1</code>: Have you experienced difficulties with thinking or memory that is happening more often or is getting worse?
<ul>
<li>1 - Yes; 2 - No; 7 - Don’t know; 9 - Refused</li>
</ul></li>
</ul>
<p>The imputation method that we chose to use was <strong>Predicted Mean Matching (PMM).</strong> This is a reliable prediction strategy that keeps the data realistic by maintaining the original shape and spread of the data. The algorithm works by finding a small group of instances (the default is 5 which was used) that are very similar to the instance that you are imputing. This similarity is based on specified fields. Once those are identified, a random complete instance (has an observed value in the field that is being imputed) is selected. This ensures that the imputed value is an actual value, not just a generated average. In the case of this dataset where the values are specific integers, this detail is even more crucial.</p>
<p>The predictor fields that we used to impute these values were selected based on prior knowledge and our own hypotheses. These included a wide range of demographic, health, and miscellaneous info.</p>
<p>Predictors:</p>
<ul>
<li><code>MARITAL</code>: Marital Status</li>
<li><code>EDUCA</code>: Education Level</li>
<li><code>VETERAN3</code>: Veteran Status</li>
<li><code>EMPLOY1</code>: Employment Status</li>
<li><code>CHILDREN</code>: Number of Children in Household</li>
<li><code>INCOME3</code>: Income Level</li>
<li><code>PREGNANT</code>: Pregnancy Status</li>
<li><code>WEIGHT2</code>: Reported Weight in Pounds</li>
<li><code>CRACE1</code>: Child Non-Hispanic Race including Multiracial</li>
<li><code>ASTHMS1</code>: Asthma Status</li>
<li><code>CAGEG</code>: Child age</li>
<li><code>AGE80</code>: Age value (collapsed above 80)</li>
<li><code>CHCOCNC1</code>: Ever told you had melanoma or any other types of cancer</li>
<li><code>ALCDAY4</code>: Days in past 30 had alcoholic beverage</li>
<li><code>MARJSMOK</code>: Did you smoke marijuana or cannabis</li>
<li><code>GENHLTH</code>: General Health</li>
<li><code>MENTHLTH</code>: Number of Days Mental Health Not Good (out of the past month)</li>
</ul>
<p>We kept 3 imputed versions of each column, along with the original column, in the resulting dataset after imputation.</p>
<p>To ensure that the imputation worked properly and didn’t skew the results, we then analyzed the distributions of the original columns compared to their imputed versions. A summary of these distributions is shown in the figure below:</p>
<p><img src="images/OriginalsVsImputed.png" class="img-fluid"></p>
<p>The distributions of all the imputed columns look extremely similar to their corresponding original distribution, convincing us that the PMM imputation worked very well. However, this dataset still isn’t ready for use, as it needs to be turned into a tidy format.</p>
</section>
<section id="tidying-the-dataset" class="level3">
<h3 class="anchored" data-anchor-id="tidying-the-dataset">Tidying the Dataset</h3>
<p>We first split up the new and complete BRFSS dataset into 3 applicable datasets named Demographics, CognitiveDecline, and TobaccoUse.</p>
<p>The Demographics dataset included columns: <code>SEQNO</code>, <code>AGE80</code>, <code>CAGEG</code>, <code>CRACE1</code>, <code>MARITAL</code>, <code>EDUCA</code>, <code>INCOME3</code>, <code>EMPLOY1</code>, <code>CHILDREN</code>, <code>VETERAN3</code>, <code>PREGNANT</code>, <code>WEIGHT2</code>, <code>GENHLTH</code>, <code>MENTHLTH</code>).</p>
<p>CognitiveDecline included columns: (<code>SEQNO</code>, <code>CIMEMLO1</code>, <code>CIMEMLO1_IMP1</code>,<code>CIMEMLO1_IMP2</code>,<code>CIMEMLO1_IMP3</code>).</p>
<p>TobaccoUse included columns: (<code>SEQNO</code>, <code>SMOKE100</code>, <code>SMOKE100_IMP1</code>, <code>SMOKE100_IMP2</code>, <code>SMOKE100_IMP3</code>, <code>ECIGNOW</code>, <code>ECIGNOW_IMP1</code>, <code>ECIGNOW_IMP2</code>, <code>ECIGNOW_IMP3</code>, <code>SMOKER3</code>)</p>
<p>After splitting up the dataset, we verified that SEQNO is unique with in each year’s BRFSS Missouri subset and can use it as the primary key when splitting into multiple related tables. This was confirmed when the output revealed no duplicate SEQNO ID/numbers, which documents it as a single column key and normal form. ### R Package</p>
<p>Mitch</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>In this project, we transformed raw BRFSS Missouri data into a clean, well-structured, and user-friendly R package that makes access easier to two important public health modules: Cognitive Decline and Tobacco Use. By downloading and cleaning the 2023 and 2024 datasets, we created a reproducible workflow that makes these large and complex data files available with a single function call. Our work addressed challenges such as inconsistent variable naming across years, missing values, and imputating missing values, while still allowing the usability of the original survey responses.</p>
<p>Through MCAR testing, we confirmed that missingness patterns were not completely at random, and we used Predictive Mean Matching (PMM) to impute three fields. Plots showed that the PMM imputations closely reflected the original data distributions, showing that PMM worked well. After imputation, we reorganized the cleaned data into tidy seperate datasets (Demographics, CognitiveDecline, and TobaccoUse) built using SEQNO as a key. This structure makes the dataset easier to explore and analyze in future projects.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>